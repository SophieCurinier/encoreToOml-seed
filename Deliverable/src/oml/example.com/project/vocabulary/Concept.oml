@dc:description "A vocabulary about the electronic datasheet"
vocabulary <http://example.com/project/vocabulary/Concept#> as Concept {
	
	extends <http://www.w3.org/2001/XMLSchema#> as xsd

    extends <http://www.w3.org/2000/01/rdf-schema#> as rdfs
    
    extends <http://purl.org/dc/elements/1.1/> as dc
    

    
    extends <http://example.com/project/vocabulary/Component#> as component
    
    extends <http://example.com/project/vocabulary/Package#> as package
    
    extends <http://example.com/project/vocabulary/Metadata#> as metadata
    
    extends <http://example.com/project/vocabulary/Interface#> as interface
    
    extends <http://example.com/project/vocabulary/Activity#> as activity
    
    extends <http://example.com/project/vocabulary/StateMachine#> as stateMachine
    
    extends <http://example.com/project/vocabulary/DataType#> as dataType
	
	    // RELATIONS BETWEEN ELEMENTS
    
    @rdfs:comment "Relation between metadata and device"
    relation entity ContainsMetadata [
    	from Device
    	to metadata:Metadata
    	forward containsMetadata
    	reverse hasDevice
    	functional
    	inverse functional	
    ]
    
    
    @rdfs:comment "Relation between datasheet and device"
    relation entity DatasheetContainsDevice [
    	from DataSheet
    	to Device
    	forward datasheetContainsDevice
    	reverse isDeviceOfDatasheet
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between datasheet and package"
    relation entity DatasheetContainsPackage [
    	from DataSheet
    	to package:Package
    	forward datasheetContainsPackage
    	reverse isPackageOfDatasheet
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between package and component"
    relation entity ComponentContainsPackage [
    	from component:Component
    	to package:Package
    	forward containsPackage
    	reverse isPackageContainedBy
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between package and interface"
    relation entity InterfaceDeclaresPackage [
    	from interface:Interface
    	to package:Package
    	forward declaresPackage
    	reverse isPackageDeclaredBy
    	functional
    	inverse functional	
    ]   

    @rdfs:comment "Relation between package and datatype"
    relation entity DataTypeDefinesPackage [
    	from dataType:DataType
    	to package:Package
    	forward definesPackage
    	reverse isPackageDefinedBy
    	functional
    	inverse functional	
    ]    

    @rdfs:comment "Relation between interface and component"
    relation entity ComponentReferencesInterface [
    	from component:Component
    	to interface:Interface
    	forward referencesInterface
    	reverse isInterfaceReferencedBy
    	functional
    	inverse functional	
    ]
 
    @rdfs:comment "Relation between interface and datatype"
    relation entity InterfaceReferencesDataType [
    	from interface:Interface
    	to dataType:DataType
    	forward referencesDataType
    	reverse isDataTypeReferencedBy
    	functional
    	inverse functional	
    ]

    @rdfs:comment "Relation between state machine and component"
    relation entity StateMachineDefinedByComponent [
    	from stateMachine:StateMachine
    	to component:Component
    	forward definedByComponent
    	reverse definesStateMachine
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between activity and component"
    relation entity ActivityContainsComponent [
    	from activity:Activity
    	to component:Component
    	forward containsComponent
    	reverse isComponentContainedBy
    	functional
    	inverse functional	
    ]

    @rdfs:comment "Relation between activity and state machine"
    relation StateMachineControlsActivity [
    	from stateMachine:StateMachine
    	to activity:Activity
    ]
    
    @rdfs:comment "Relation between scalar and range"
    relation entity RangeLimitsScalar [
    	from dataType:Range
    	to dataType:Scalar
    	forward limitsScalar
    	reverse isLimitedBy
    	functional
    	inverse functional	
    ]
    

    relation EntriesOnContainer[
    	from Entries
    	to dataType:Container
    ]
    
    @rdfs:comment "The class of things that are uniquely identified by id"
    aspect IdentifiedThing [
        key hasId
    ]
    
    aspect NamedEntityType [
    	key name
    	key shortDescription
    	key longDescription
    ]
    
    @rdfs:comment "The id property of an identified thing"
    scalar property hasId [
        domain DataSheet
        range xsd:string
        functional
    ]
    
    @rdfs:comment "The name of a namedEntitype"
    scalar property name [
        domain NamedEntityType
        range xsd:string
        functional
    ]
    

    @rdfs:comment "The short description of a namedEntitype"
    scalar property shortDescription [
        domain NamedEntityType
        range xsd:string
        functional
    ]
    
    @rdfs:comment "The long description of a namedEntitype"
    scalar property longDescription [
        domain NamedEntityType
        range xsd:string
        functional
    ]
    

    @rdfs:comment "The class of datasheet"
    concept DataSheet < IdentifiedThing 
    
    @rdfs:comment "The class of device items"
    concept Device < NamedEntityType

    
    // Field Element
    
    @rdfs:comment "The class of field"
    concept Field < NamedEntityType
   
    @rdfs:comment "The subclass of type field"
    concept ExternalField < Field

 
    concept Entries < ExternalField

    
    
}