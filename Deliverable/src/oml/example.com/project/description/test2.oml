vocabulary <http://example.com/project/description/test2#> as test2 {
	
	extends <http://www.w3.org/2001/XMLSchema#> as xsd

    extends <http://purl.org/dc/elements/1.1/> as dc

    extends <http://www.w3.org/2000/01/rdf-schema#> as rdfs
	
	// Top Level
    
    @rdfs:comment "The class of things that are uniquely identified by id"
    aspect IdentifiedThing [
        key hasId
    ]
    
    @rdfs:comment "The class of datasheet"
    aspect DataSheet [
    	key hasId
    ]
    
    @rdfs:comment "The id property of an identified thing"
    scalar property hasId [
        domain DataSheet
        range xsd:string
        functional
    ]
    
    // DataSheet

    @rdfs:comment "The class of device items"
    concept Device < DataSheet[
    	restricts hasTension to "5V"
    	restricts some hasData to Metadata

    	]
    
    
    @rdfs:comment "The class of package items"
    concept Package < IdentifiedThing
    
    // Package
    @rdfs:comment "The class of component items"
    concept Component < IdentifiedThing
    
    @rdfs:comment "The class of interface items"
    concept Interface < IdentifiedThing
    
    @rdfs:comment "The class of component datatype"
    concept DataType < IdentifiedThing
    
    // Component
    @rdfs:comment "The class of state machine items"
    concept StateMachine < IdentifiedThing
    
    @rdfs:comment "The class of activity items"
    concept Activity < IdentifiedThing
    
    // DataType
    @rdfs:comment "The class of array items"
    concept Array < DataType
    
    @rdfs:comment "The class of container items"
    concept Container < DataType
    
    @rdfs:comment "The class of scalar items"
    concept Scalar < DataType
    
    @rdfs:comment "The class of range items"
    concept Range < IdentifiedThing
    
    @rdfs:comment "Relation between metadata and device"
    relation entity ContainsDevice [
    	from Metadata
    	to Device
    	forward fromDevice
    	reverse hasData
    	functional
    	inverse functional	
    ]
    
    
    @rdfs:comment "Relation between datasheet and device"
    relation entity DeviceContainsDatasheet [
    	from Device
    	to DataSheet
    	forward deviceContainsDatasheet
    	reverse isDatasheetOfDevice
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between datasheet and package"
    relation entity PackageContainsDatasheet [
    	from Package
    	to DataSheet
    	forward packageContainsDatasheet
    	reverse isDatasheetOfPackage
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between package and component"
    relation entity ContainsPackage [
    	from Component
    	to Package
    	forward containsPackage
    	reverse isPackageContainedBy
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between package and interface"
    relation entity DeclaresPackage [
    	from Interface
    	to Package
    	forward declaresPackage
    	reverse isPackageDeclaredBy
    	functional
    	inverse functional	
    ]   

    @rdfs:comment "Relation between package and datatype"
    relation entity DefinesPackage [
    	from DataType
    	to Package
    	forward definesPackage
    	reverse isPackageDefinedBy
    	functional
    	inverse functional	
    ]    

    @rdfs:comment "Relation between interface and component"
    relation entity ReferencesInterface [
    	from Component
    	to Interface
    	forward referencesInterface
    	reverse isInterfaceReferencedBy
    	functional
    	inverse functional	
    ]
 
    @rdfs:comment "Relation between interface and datatype"
    relation entity ReferencesDataType [
    	from Interface
    	to DataType
    	forward referencesDataType
    	reverse isDataTypeReferencedBy
    	functional
    	inverse functional	
    ]

    @rdfs:comment "Relation between state machine and component"
    relation entity DefinedByComponent [
    	from StateMachine
    	to Component
    	forward definedByComponent
    	reverse definesStateMachine
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between activity and component"
    relation entity ContainsComponent [
    	from Activity
    	to Component
    	forward containsComponent
    	reverse isComponentContainedBy
    	functional
    	inverse functional	
    ]

    @rdfs:comment "Relation between activity and state machine"
    relation entity ControlsActivity [
    	from StateMachine
    	to Activity
    	forward controlsActivity
    	reverse isControledBy
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between scalar and range"
    relation entity LimitsScalar [
    	from Range
    	to Scalar
    	forward limitsScalar
    	reverse isLimitedBy
    	functional
    	inverse functional	
    ]
    
    // 
    scalar Tension [
    	oneOf "0V", "5V", "10V"
    ]
    
    scalar property hasTension[
    	domain Device
    	range Tension
    	functional
    ]
    
    concept Metadata < IdentifiedThing[
    	restricts some fromDevice to Device
    ]
    
    

//    @rdfs:comment "A relation from a food to another used as an ingredient"
//    relation entity HasIngredient [
//        from Device
//        to Device
//        forward hasIngredient
//        reverse isIngredientOf
//        transitive
//    ]
//
//    @rdfs:comment "An enumeration of spiciness levels"
//    scalar Spiciness [
//        oneOf "Hot", "Medium", "Mild"
//    ]
//
//    @rdfs:comment "The spiciness property of a food item"
//    scalar property hasSpiceness [
//        domain Food
//        range Spiciness
//        functional
//    ]
//    
//    // Foods
//    
//    @rdfs:comment "The class of pizzas"
//    concept Pizza < Device [
//        restricts some hasBase to PizzaBase
//    ]
//
//    @rdfs:comment "The class of pizza bases"
//    concept PizzaBase < Device
//
//    @rdfs:comment "The class of pizza toppings"
//    concept PizzaTopping < Device
//
//    @rdfs:comment "A relation from a pizza to a base"
//    relation entity HasBase [
//        from Pizza
//        to PizzaBase
//        forward hasBase
//        reverse isBaseOf
//        functional
//        inverse functional
//    ] < HasIngredient 
//
//    @rdfs:comment "A relation from a pizza to a topping"
//    relation entity HasTopping [
//        from Pizza
//        to PizzaTopping
//        forward hasTopping
//        reverse isToppingOf
//        inverse functional
//    ] < HasIngredient
    
}