vocabulary <http://example.com/project/description/test2#> as test2 {
	
	extends <http://www.w3.org/2001/XMLSchema#> as xsd

    extends <http://purl.org/dc/elements/1.1/> as dc

    extends <http://www.w3.org/2000/01/rdf-schema#> as rdfs
	
	// Aspect
    
    @rdfs:comment "The class of things that are uniquely identified by id"
    aspect IdentifiedThing [
        key hasId
    ]
    
    aspect NamedEntityType [
    	key name
    	key shortDescription
    	key longDescription
    ]
    
	
	// Scalar property
	
    scalar Tension [
    	oneOf "0V", "5V", "10V"
    ]
    
    scalar State [
    	oneOf "EntryState", "ExitState", "State", "Transition"
    ]
    
    scalar property hasTension[
    	domain Device
    	range Tension
    	functional
    ]
    
    scalar property defaultEntryState[
    	domain StateMachine
    	range State
    	functional
    ]
    
    scalar property level [
    	domain Interface
    	range xsd:float
    	functional
    ]
    
    
    @rdfs:comment "The id property of an identified thing"
    scalar property hasId [
        domain DataSheet
        range xsd:string
        functional
    ]
    
    @rdfs:comment "The name of a namedEntitype"
    scalar property name [
        domain NamedEntityType
        range xsd:string
        functional
    ]
    
    @rdfs:comment "The short description of a namedEntitype"
    scalar property shortDescription [
        domain NamedEntityType
        range xsd:string
        functional
    ]
    
    @rdfs:comment "The long description of a namedEntitype"
    scalar property longDescription [
        domain NamedEntityType
        range xsd:string
        functional
    ]
    
    @rdfs:comment "The abstract of a interface"
    scalar property abstract [
    	domain Interface
    	range xsd:boolean
    	functional
    ]
    
    // Concept

    concept Metadata < IdentifiedThing[
    	restricts some fromDevice to Device
    ]
    

    @rdfs:comment "The class of datasheet"
    concept DataSheet < IdentifiedThing 
    
    @rdfs:comment "The class of device items"
    concept Device < NamedEntityType[
    	restricts hasTension to "5V"
    	restricts some hasData to Metadata

    	]

    
    @rdfs:comment "The class of package items"
    concept Package < NamedEntityType
    
    // Package
    @rdfs:comment "The class of component items"
    concept Component < NamedEntityType
    
    @rdfs:comment "The class of interface items"
    concept Interface < IdentifiedThing[
    	restricts abstract to true
    	restricts level to max 4
    	restricts level to min 3
    ]
    
    @rdfs:comment "The class of component datatype"
    concept DataType < NamedEntityType
    
    // Component
    @rdfs:comment "The class of state machine items"
    concept StateMachine < IdentifiedThing
    
    @rdfs:comment "The class of activity items"
    concept Activity < NamedEntityType
    
    // DataType
    @rdfs:comment "The class of array items"
    concept Array < DataType
    
    @rdfs:comment "The class of container items"
    concept Container < DataType
    
    @rdfs:comment "The class of scalar items"
    concept Scalar < DataType
    
    @rdfs:comment "The class of range items"
    concept Range < IdentifiedThing
    
    
    // RELATIONS BETWEEN ELEMENTS
    
    @rdfs:comment "Relation between metadata and device"
    relation entity ContainsDevice [
    	from Metadata
    	to Device
    	forward fromDevice
    	reverse hasData
    	functional
    	inverse functional	
    ]
    
    
    @rdfs:comment "Relation between datasheet and device"
    relation entity DeviceContainsDatasheet [
    	from Device
    	to DataSheet
    	forward deviceContainsDatasheet
    	reverse isDatasheetOfDevice
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between datasheet and package"
    relation entity PackageContainsDatasheet [
    	from Package
    	to DataSheet
    	forward packageContainsDatasheet
    	reverse isDatasheetOfPackage
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between package and component"
    relation entity ContainsPackage [
    	from Component
    	to Package
    	forward containsPackage
    	reverse isPackageContainedBy
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between package and interface"
    relation entity DeclaresPackage [
    	from Interface
    	to Package
    	forward declaresPackage
    	reverse isPackageDeclaredBy
    	functional
    	inverse functional	
    ]   

    @rdfs:comment "Relation between package and datatype"
    relation entity DefinesPackage [
    	from DataType
    	to Package
    	forward definesPackage
    	reverse isPackageDefinedBy
    	functional
    	inverse functional	
    ]    

    @rdfs:comment "Relation between interface and component"
    relation entity ReferencesInterface [
    	from Component
    	to Interface
    	forward referencesInterface
    	reverse isInterfaceReferencedBy
    	functional
    	inverse functional	
    ]
 
    @rdfs:comment "Relation between interface and datatype"
    relation entity ReferencesDataType [
    	from Interface
    	to DataType
    	forward referencesDataType
    	reverse isDataTypeReferencedBy
    	functional
    	inverse functional	
    ]

    @rdfs:comment "Relation between state machine and component"
    relation entity DefinedByComponent [
    	from StateMachine
    	to Component
    	forward definedByComponent
    	reverse definesStateMachine
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between activity and component"
    relation entity ContainsComponent [
    	from Activity
    	to Component
    	forward containsComponent
    	reverse isComponentContainedBy
    	functional
    	inverse functional	
    ]

    @rdfs:comment "Relation between activity and state machine"
    relation entity ControlsActivity [
    	from StateMachine
    	to Activity
    	forward controlsActivity
    	reverse isControledBy
    	functional
    	inverse functional	
    ]
    
    @rdfs:comment "Relation between scalar and range"
    relation entity LimitsScalar [
    	from Range
    	to Scalar
    	forward limitsScalar
    	reverse isLimitedBy
    	functional
    	inverse functional	
    ]
   
    
    
}